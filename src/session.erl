%%% @doc Handle session cookies.
%%%
%%%  cookie = session_id | expiration | mac
%%%
%%% ...where session_id is a randomly-generated number,
%%%
%%% expiration is the time until this session expires. See the note about
%%% session expiry.
%%%
%%% mac is a signature of the rest of the cookie, preventing recovery of a
%%% session_id cookie and extending the expiry.
-module(session).
-export([get_session/1, get_cookie/1]).

get_session(undefined) ->
    undefined;
get_session(Cookie) ->
    lager:debug("Cookie ~p", [Cookie]),
    undefined.

            % Cookie consists of |session_id|expiry|mac|
            % mac is a signature of the rest of the cookie; it's generated by:
            %   - server key?
            %   - server run key?
            %   - a key associated with session_id, which is stored in ETS, thus ephemeral-ish.

    % @todo Look for a session ID in the cookies. If there's one there, look up the corresponding user ID.
    % Then you're authenticated.
    % Possible attack:
    %  Cookie replay:
    %    - protect it with httponly/secure -- makes it harder to get hold of.
    %  It's a password equivalent:
    %    - store it in ephemeral store, so it's not easy to grab => ETS
    %    - make it fairly short-lived; if the user remains logged-in, we'll give them a fresh one on each request;
    %    - if it's been too long since we generated this cookie, then game over.

get_cookie(_SessionId) ->
    undefined.

transcript() ->
    % 16 bytes is 128 bits. As far as I can work out, that's plenty, provided
    % the key is kept secret. The key is then kept in an ETS table, keyed by session ID.
    Key = crypto:rand_bytes(16),
    % This is just the random session ID. It doesn't need to be too long.
    Data = crypto:rand_bytes(16),
    Mac = crypto:hmac(sha256, Key, Data),
    Mac.
